/* automatically generated by rust-bindgen 0.69.4 */

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &[u8; 9] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &[u8; 6] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __VISIONOS_1_0: u32 = 10000;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140200;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const HBASE_LATEST_TIMESTAMP: u64 = 9223372036854775807;
pub const HBASE_INTERNAL_ERR: i32 = -10000;
pub const HBASE_TABLE_DISABLED: i32 = -10001;
pub const HBASE_TABLE_NOT_DISABLED: i32 = -10002;
pub const HBASE_UNKNOWN_SCANNER: i32 = -10003;
pub const HBASE_REPL_SRC_TABLE_NOT_FOUND: i32 = -10020;
pub const HBASE_REPL_REPLICA_TABLE_NOT_FOUND: i32 = -10021;
pub const HBASE_REPL_UPSTREAM_NOT_FOUND: i32 = -10022;
pub const HBASE_REPL_REPLICA_NOT_FOUND: i32 = -10023;
pub const HBASE_REPL_NEW_REPLICA_TABLE_NOT_FOUND: i32 = -10024;
pub const HBASE_REPL_CF_NOT_FOUND: i32 = -10025;
pub const HBASE_REPL_REPLICA_EXIST: i32 = -10026;
pub const HBASE_REPL_UPSTREAM_EXIST: i32 = -10027;
pub const HBASE_REPL_LICENSE_ERROR: i32 = -10028;
pub const HBASE_REPL_REPLICA_SAME: i32 = -10029;
pub const HBASE_REPL_BULKLOAD_TRUE: i32 = -10030;
pub const HBASE_REPL_OP_OUTSTANDING: i32 = -10031;
pub const HBASE_REPL_PERMISSION_ERROR: i32 = -10032;
pub const HBASE_REPL_REPLICA_DIR_NOT_EXIST: i32 = -10033;
pub const HBASE_REPL_MULTI_MASTER_WITH_EXISTING_REPLICA: i32 = -10034;
pub const HBASE_REPL_DIRECTCOPY_NOT_ENABLED: i32 = -10035;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
pub type byte_t = u8;
#[doc = " Base HBase Cell type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_cell_type {
    pub row: *mut byte_t,
    pub row_len: usize,
    pub family: *mut byte_t,
    pub family_len: usize,
    pub qualifier: *mut byte_t,
    pub qualifier_len: usize,
    pub value: *mut byte_t,
    pub value_len: usize,
    pub ts: i64,
    pub flags_: i64,
    pub private_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_hb_cell_type() {
    const UNINIT: ::std::mem::MaybeUninit<hb_cell_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_cell_type>(),
        88usize,
        concat!("Size of: ", stringify!(hb_cell_type))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_cell_type>(),
        8usize,
        concat!("Alignment of ", stringify!(hb_cell_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(row_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(family_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qualifier) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(qualifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qualifier_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(qualifier_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(value_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(flags_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_cell_type),
            "::",
            stringify!(private_)
        )
    );
}
#[doc = " Base HBase Cell type."]
pub type hb_cell_t = hb_cell_type;
pub type hb_connection_t = *mut ::std::os::raw::c_void;
pub type hb_client_t = *mut ::std::os::raw::c_void;
pub type hb_admin_t = *mut ::std::os::raw::c_void;
pub type hb_table_t = *mut ::std::os::raw::c_void;
pub type hb_get_t = *mut ::std::os::raw::c_void;
pub type hb_multiget_t = *mut ::std::os::raw::c_void;
pub type hb_result_t = *mut ::std::os::raw::c_void;
pub type hb_mutation_t = *mut ::std::os::raw::c_void;
pub type hb_put_t = *mut ::std::os::raw::c_void;
pub type hb_delete_t = *mut ::std::os::raw::c_void;
pub type hb_increment_t = *mut ::std::os::raw::c_void;
pub type hb_append_t = *mut ::std::os::raw::c_void;
pub type hb_scanner_t = *mut ::std::os::raw::c_void;
pub type hb_columndesc = *mut ::std::os::raw::c_void;
pub type hb_repl_stats_t = *mut ::std::os::raw::c_void;
pub type hb_repl_desc_iter_t = *mut ::std::os::raw::c_void;
pub type hb_repl_desc_t = *mut ::std::os::raw::c_void;
pub type hb_repl_column_t = *mut ::std::os::raw::c_void;
pub const hb_durability_t_DURABILITY_USE_DEFAULT: hb_durability_t = 0;
pub const hb_durability_t_DURABILITY_SKIP_WAL: hb_durability_t = 1;
pub const hb_durability_t_DURABILITY_ASYNC_WAL: hb_durability_t = 2;
pub const hb_durability_t_DURABILITY_SYNC_WAL: hb_durability_t = 3;
pub const hb_durability_t_DURABILITY_FSYNC_WAL: hb_durability_t = 4;
pub type hb_durability_t = ::std::os::raw::c_uint;
pub const hb_replication_state_t_COPY_IN_PROGRESS: hb_replication_state_t = 0;
pub const hb_replication_state_t_REPLICATING: hb_replication_state_t = 1;
#[doc = " Replication state"]
pub type hb_replication_state_t = ::std::os::raw::c_uint;
pub const hb_compression_type_t_off: hb_compression_type_t = 0;
pub const hb_compression_type_t_lzf: hb_compression_type_t = 2;
pub const hb_compression_type_t_lz4: hb_compression_type_t = 3;
pub const hb_compression_type_t_zlib: hb_compression_type_t = 4;
#[doc = " Replication on-wire compression type. Default: lz4"]
pub type hb_compression_type_t = ::std::os::raw::c_uint;
pub const HBaseLogLevel_HBASE_LOG_LEVEL_INVALID: HBaseLogLevel = 0;
pub const HBaseLogLevel_HBASE_LOG_LEVEL_FATAL: HBaseLogLevel = 1;
pub const HBaseLogLevel_HBASE_LOG_LEVEL_ERROR: HBaseLogLevel = 2;
pub const HBaseLogLevel_HBASE_LOG_LEVEL_WARN: HBaseLogLevel = 3;
pub const HBaseLogLevel_HBASE_LOG_LEVEL_INFO: HBaseLogLevel = 4;
pub const HBaseLogLevel_HBASE_LOG_LEVEL_DEBUG: HBaseLogLevel = 5;
pub const HBaseLogLevel_HBASE_LOG_LEVEL_TRACE: HBaseLogLevel = 6;
#[doc = "  Log levels"]
pub type HBaseLogLevel = ::std::os::raw::c_uint;
#[doc = " HBase Admin disconnection callback typedef\n\n This callback is triggered after the connections are closed, but just before\n the client is freed.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_admin_disconnection_cb = ::std::option::Option<
    unsafe extern "C" fn(err: i32, admin: hb_admin_t, extra: *mut ::std::os::raw::c_void),
>;
#[doc = " Client disconnection callback typedef\n This callback is triggered after the connections are closed, but just before\n the client is freed.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_client_disconnection_cb = ::std::option::Option<
    unsafe extern "C" fn(err: i32, client: hb_client_t, extra: *mut ::std::os::raw::c_void),
>;
#[doc = " Client flush callback typedef\n This callback is invoked when everything that was buffered at the time of\n the call has been flushed.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_client_flush_cb = ::std::option::Option<
    unsafe extern "C" fn(err: i32, client: hb_client_t, extra: *mut ::std::os::raw::c_void),
>;
#[doc = " Mutation callback typedef\n\n This callback is triggered with the result of each mutation.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_mutation_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        client: hb_client_t,
        mutation: hb_mutation_t,
        result: hb_result_t,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Get callback typedef\n This callback is triggered with the result of each Get call.\n\n The result, if not NULL, must be freed by calling hb_result_destroy().\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_get_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        client: hb_client_t,
        get: hb_get_t,
        result: hb_result_t,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " MultiGet callback typedef\n This callback is triggered with the result of each Get call.\n\n The result, if not NULL, must be freed by calling hb_result_destroy().\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_multiget_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        client: hb_client_t,
        get: hb_multiget_t,
        results: *mut hb_result_t,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Scanner callback typedef\n This callback is triggered when scanner next returns results.\n\n The individual results in the results array must be freed by calling\n hb_result_destroy(). The array itself is freed once the callback returns.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_scanner_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        scanner: hb_scanner_t,
        results: *mut hb_result_t,
        num_results: usize,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Scanner close callback typedef\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_scanner_destroy_cb = ::std::option::Option<
    unsafe extern "C" fn(err: i32, scanner: hb_scanner_t, extra: *mut ::std::os::raw::c_void),
>;
#[doc = " Replication add replica callback typedef\n This callback is triggered when replica add finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_add_replica_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        rp: hb_repl_desc_t,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication add upstream callback typedef\n This callback is triggered when upstream add finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_add_upstream_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        src: *const ::std::os::raw::c_char,
        replica: *const ::std::os::raw::c_char,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication remove replica callback typedef\n This callback is triggered when replica remove finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_remove_replica_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        src: *const ::std::os::raw::c_char,
        replica: *const ::std::os::raw::c_char,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication remove upstream callback typedef\n This callback is triggered when upstream remove finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_remove_upstream_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        src: *const ::std::os::raw::c_char,
        replica: *const ::std::os::raw::c_char,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication edit replica callback typedef\n This callback is triggered when replica edit finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_edit_replica_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        rp: hb_repl_desc_t,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication pause replica callback typedef\n This callback is triggered when replication pause finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_pause_replica_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        src: *const ::std::os::raw::c_char,
        replica: *const ::std::os::raw::c_char,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication resume replica callback typedef\n This callback is triggered when replication resume finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_resume_replica_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        src: *const ::std::os::raw::c_char,
        replica: *const ::std::os::raw::c_char,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication list replica callback typedef\n This callback is triggered when replica list finishes\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_list_replica_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        src: *const ::std::os::raw::c_char,
        it: hb_repl_desc_iter_t,
        refresh: bool,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication list upstream callback typedef\n This callback is triggered when upstream list finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_list_upstream_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        replica: *const ::std::os::raw::c_char,
        it: hb_repl_desc_iter_t,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Replication autosetup callback typedef\n This callback is triggered when autosetup finishes.\n\n Refer to the section on error code for the list of possible values\n for 'err'. A value of 0 indicates success."]
pub type hb_repl_auto_setup_cb = ::std::option::Option<
    unsafe extern "C" fn(
        err: i32,
        admin: hb_admin_t,
        rp: hb_repl_desc_t,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Create a new hb_admin.\n All fields are initialized to the defaults. If you want to set\n connection or other properties, set those before calling any\n RPC functions."]
    pub fn hb_admin_create(connection: hb_connection_t, admin_ptr: *mut hb_admin_t) -> i32;
}
extern "C" {
    #[doc = " Disconnect the admin releasing any internal objects\n or connections created in the background."]
    pub fn hb_admin_destroy(
        admin: hb_admin_t,
        cb: hb_admin_disconnection_cb,
        extra: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Checks if a table exists.\n @returns 0 on if the table exist, an error code otherwise."]
    pub fn hb_admin_table_exists(
        admin: hb_admin_t,
        name_space: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Checks if a table is enabled.\n @returns 0 on if the table enabled, HBASE_TABLE_DISABLED if the table\n is disabled or an error code if an error occurs."]
    pub fn hb_admin_table_enabled(
        admin: hb_admin_t,
        name_space: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Creates an HBase table.\n @returns 0 on success, an error code otherwise."]
    pub fn hb_admin_table_create(
        admin: hb_admin_t,
        name_space: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        families: *const hb_columndesc,
        num_families: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Adds a column family to an HBase table.\n @returns 0 on success, an error code otherwise."]
    pub fn hb_admin_table_add_column_family(
        admin: hb_admin_t,
        name_space: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        family: hb_columndesc,
    ) -> i32;
}
extern "C" {
    #[doc = " Modifies a column family of an HBase table.\n @returns 0 on success, an error code otherwise."]
    pub fn hb_admin_table_modify_column_family(
        admin: hb_admin_t,
        name_space: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        family: hb_columndesc,
    ) -> i32;
}
extern "C" {
    #[doc = " Disable an HBase table.\n @returns 0 on success, an error code otherwise."]
    pub fn hb_admin_table_disable(
        admin: hb_admin_t,
        name_space: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Enable an HBase table.\n @returns 0 on success, an error code otherwise."]
    pub fn hb_admin_table_enable(
        admin: hb_admin_t,
        name_space: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Deletes an HBase table, disables the table if not already disabled.\n Returns 0 on success, and error code otherwise."]
    pub fn hb_admin_table_delete(
        admin: hb_admin_t,
        name_space: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Initializes a handle to hb_client_t which can be passed to other HBase APIs.\n You need to use this method only once per HBase cluster. The returned handle\n is thread safe.\n\n @returns 0 on success, non-zero error code in case of failure."]
    pub fn hb_client_create(connection: hb_connection_t, client_ptr: *mut hb_client_t) -> i32;
}
extern "C" {
    #[doc = " Flushes any buffered client-side write operations to HBase.\n The callback will be invoked when everything that was buffered at the time of\n the call has been flushed.\n Note that this doesn't guarantee that ALL outstanding RPCs have completed."]
    pub fn hb_client_flush(
        client: hb_client_t,
        cb: hb_client_flush_cb,
        extra: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Cleans up hb_client_t handle and release any held resources.\n The callback is called after the connections are closed, but just before the\n client is freed."]
    pub fn hb_client_destroy(
        client: hb_client_t,
        cb: hb_client_disconnection_cb,
        extra: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Creates a column family descriptor.\n @returns a handle to an hb_columndesc object or NULL if unsuccessful."]
    pub fn hb_coldesc_create(
        family: *const byte_t,
        family_len: usize,
        col_desc: *mut hb_columndesc,
    ) -> i32;
}
extern "C" {
    #[doc = " Release resources held by column family descriptor."]
    pub fn hb_coldesc_destroy(col_desc: hb_columndesc) -> i32;
}
extern "C" {
    #[doc = " Sets the maximum number of cell versions to be retained for the column\n family. Defaults to 3."]
    pub fn hb_coldesc_set_maxversions(col_desc: hb_columndesc, max_versions: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the minimum number of cell versions to be retained for the column\n family. Defaults to 0."]
    pub fn hb_coldesc_set_minversions(col_desc: hb_columndesc, min_versions: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the time-to-live of cell contents, in seconds. Defaults is forever."]
    pub fn hb_coldesc_set_ttl(col_desc: hb_columndesc, ttl: i32) -> i32;
}
extern "C" {
    #[doc = " Sets if all values are to keep in the HRegionServer cache. Defaults to\n 0 (false)."]
    pub fn hb_coldesc_set_inmemory(col_desc: hb_columndesc, inmemory: i32) -> i32;
}
extern "C" {
    #[doc = " Creates an hb_connection_t instance and initializes its address into\n the passed pointer."]
    pub fn hb_connection_create(
        zk_quorum: *const ::std::os::raw::c_char,
        zk_root: *const ::std::os::raw::c_char,
        connection_ptr: *mut hb_connection_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Creates an hb_connection_t instance for a specific user and initializes its\n address into the passed pointer."]
    pub fn hb_connection_create_as_user(
        zk_quorum: *const ::std::os::raw::c_char,
        zk_root: *const ::std::os::raw::c_char,
        user: *const ::std::os::raw::c_char,
        connection_ptr: *mut hb_connection_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Destroy the connection and free all resources allocated at creation time."]
    pub fn hb_connection_destroy(connection: hb_connection_t) -> i32;
}
extern "C" {
    #[doc = " Creates an hb_get_t object and populate the handle get_ptr."]
    pub fn hb_get_create(rk: *const byte_t, rk_len: usize, get_ptr: *mut hb_get_t) -> i32;
}
extern "C" {
    #[doc = " Queues the get request. Callback specified by cb will be called\n on completion. Any buffer(s) attached to the get object can be\n reclaimed only after the callback is received."]
    pub fn hb_get_send(
        client: hb_client_t,
        get: hb_get_t,
        cb: hb_get_cb,
        extra: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the table name, required."]
    pub fn hb_get_set_table(
        get: hb_get_t,
        table_name: *const ::std::os::raw::c_char,
        table_name_len: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " @NotYetImplemented\n\n Sets the table namespace (0.96 and later)"]
    pub fn hb_get_set_namespace(
        get: hb_get_t,
        name_space: *const ::std::os::raw::c_char,
        name_space_len: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Release any resource held by hb_get_t object."]
    pub fn hb_get_destroy(get: hb_get_t) -> i32;
}
extern "C" {
    #[doc = " Sets the row key, required."]
    pub fn hb_get_set_row(get: hb_get_t, rk: *const byte_t, rk_len: usize) -> i32;
}
extern "C" {
    #[doc = " Adds a column family and optionally a column qualifier to\n the hb_get_t object, optional."]
    pub fn hb_get_add_column(
        get: hb_get_t,
        family: *const byte_t,
        family_len: usize,
        qualifier: *const byte_t,
        qualifier_len: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " @NotYetImplemented\n\n Optional. Adds a filter to the hb_get_t object.\n\n The filter must be specified using HBase Filter Language.\n Refer to class org.apache.hadoop.hbase.filter.ParseFilter and\n https://issues.apache.org/jira/browse/HBASE-4176 or\n http://hbase.apache.org/book.html#thrift.filter-language for\n language syntax and additional details."]
    pub fn hb_get_set_filter(get: hb_get_t, filter: *const byte_t, filterLen: i32) -> i32;
}
extern "C" {
    #[doc = " Optional. Sets maximum number of latest values of each column to be\n fetched."]
    pub fn hb_get_set_num_versions(get: hb_get_t, num_versions: i32) -> i32;
}
extern "C" {
    #[doc = " Optional. Only columns with the specified timestamp will be included."]
    pub fn hb_get_set_timestamp(get: hb_get_t, ts: i64) -> i32;
}
extern "C" {
    #[doc = " Optional. Only columns with timestamp within the specified range will\n be included."]
    pub fn hb_get_set_timerange(get: hb_get_t, min_ts: i64, max_ts: i64) -> i32;
}
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log output level"]
    pub fn hb_log_set_level(level: HBaseLogLevel);
}
extern "C" {
    #[doc = " By default, the log messages are sent to stderr. Use this function to\n redirect it to another file stream. Setting it to NULL disables logging."]
    pub fn hb_log_set_stream(stream: *mut FILE);
}
extern "C" {
    #[doc = " For internal use. Use one of the macros defined later in this file."]
    pub fn hb_log_message(
        curLevel: HBaseLogLevel,
        line: ::std::os::raw::c_int,
        fileName: *const ::std::os::raw::c_char,
        funcName: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " For internal use. Use one of the macros defined later in this file."]
    pub fn hb_format_log_message(
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " For internal use. Get the log output level."]
    pub fn hb_log_get_level() -> HBaseLogLevel;
}
extern "C" {
    #[doc = " Creates a structure for put operation and return its handle."]
    pub fn hb_put_create(rowkey: *const byte_t, rowkey_len: usize, put_ptr: *mut hb_put_t) -> i32;
}
extern "C" {
    #[doc = " Creates a structure for delete operation and return its handle."]
    pub fn hb_delete_create(
        rowkey: *const byte_t,
        rowkey_len: usize,
        delete_ptr: *mut hb_delete_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Creates a structure for increment operation and return its handle."]
    pub fn hb_increment_create(
        rowkey: *const byte_t,
        rowkey_len: usize,
        increment_ptr: *mut hb_increment_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Creates an structure for append operation and return its handle."]
    pub fn hb_append_create(
        rowkey: *const byte_t,
        rowkey_len: usize,
        append_ptr: *mut hb_append_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Queue a mutation to go out. These mutations will not be performed\n atomically and can be batched in a non-deterministic way on either\n the server or the client side.\n\n Any buffer attached to the the mutation objects must not be altered\n until the callback has been received."]
    pub fn hb_mutation_send(
        client: hb_client_t,
        mutation: hb_mutation_t,
        cb: hb_mutation_cb,
        extra: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Frees up any resource held by the mutation structure."]
    pub fn hb_mutation_destroy(mutation: hb_mutation_t) -> i32;
}
extern "C" {
    #[doc = " @NotYetImplemented\n\n Sets the namespace for the mutation (0.96 and later)."]
    pub fn hb_mutation_set_namespace(
        mutation: hb_mutation_t,
        name_space: *const ::std::os::raw::c_char,
        name_space_len: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the table name for the mutation."]
    pub fn hb_mutation_set_table(
        mutation: hb_mutation_t,
        table: *const ::std::os::raw::c_char,
        table_len: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets whether or not this RPC can be buffered on the client side.\n\n Currently only puts and deletes can be buffered. Calling this for\n any other mutation type will return EINVAL.\n\n The default is true."]
    pub fn hb_mutation_set_bufferable(mutation: hb_mutation_t, bufferable: bool) -> i32;
}
extern "C" {
    #[doc = " Sets the row key for the mutation."]
    pub fn hb_mutation_set_row(
        mutation: hb_mutation_t,
        rowkey: *const byte_t,
        rowkey_len: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the durability guarantees for the Mutation."]
    pub fn hb_mutation_set_durability(mutation: hb_mutation_t, durability: hb_durability_t) -> i32;
}
extern "C" {
    #[doc = " Adds a cell to the put structure. The row key of the cell\n must be same as the row key of the put structure."]
    pub fn hb_put_add_cell(put: hb_put_t, cell: *const hb_cell_t) -> i32;
}
extern "C" {
    #[doc = " Adds a column (key-value) with latest timestamp to the put."]
    pub fn hb_put_add_column(
        put: hb_put_t,
        family: *const byte_t,
        family_len: usize,
        qualifier: *const byte_t,
        qualifier_len: usize,
        value: *const byte_t,
        value_len: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Adds a column (key-value) with the specified timestamp to the put."]
    pub fn hb_put_add_ts_column(
        put: hb_put_t,
        family: *const byte_t,
        family_len: usize,
        qualifier: *const byte_t,
        qualifier_len: usize,
        value: *const byte_t,
        value_len: usize,
        timestamp: i64,
    ) -> i32;
}
extern "C" {
    #[doc = " Optional. Set the column criteria for hb_delete_t object.\n Set the qualifier to NULL to delete all columns of a family.\n Only the cells with timestamp less than or equal to the specified\n timestamp are deleted. Set the timestamp to INT64_MAX to delete all\n versions of the column."]
    pub fn hb_delete_add_column(
        del: hb_delete_t,
        family: *const byte_t,
        family_len: usize,
        qualifier: *const byte_t,
        qualifier_len: usize,
        timestamp: i64,
    ) -> i32;
}
extern "C" {
    #[doc = " Optional. Set the column criteria for hb_delete_t object.\n Only the cells with timestamp equal to the specified\n timestamp are deleted."]
    pub fn hb_delete_add_column_exact(
        del: hb_delete_t,
        family: *const byte_t,
        family_len: usize,
        qualifier: *const byte_t,
        qualifier_len: usize,
        timestamp: i64,
    ) -> i32;
}
extern "C" {
    #[doc = " Optional. Sets the timestamp of the delete row or delete family\n operation.\n This does not override the timestamp of individual columns\n added via hb_delete_add_column()."]
    pub fn hb_delete_set_timestamp(del: hb_delete_t, timestamp: i64) -> i32;
}
extern "C" {
    #[doc = " Add a column and the amount by which its value to be incremented\n to the increment operation."]
    pub fn hb_increment_add_column(
        incr: hb_increment_t,
        cell: *const hb_cell_t,
        amount: i64,
    ) -> i32;
}
extern "C" {
    #[doc = " Add a column for the append operation."]
    pub fn hb_append_add_column(append: hb_append_t, cell: *const hb_cell_t) -> i32;
}
extern "C" {
    #[doc = " Returns the row key of this hb_result_t object.\n This buffer is valid until hb_result_destroy() is called.\n Callers should not modify this buffer."]
    pub fn hb_result_get_key(
        result: hb_result_t,
        key_ptr: *mut *const byte_t,
        key_length_ptr: *mut usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the table name of this hb_result_t object.\n This buffer is valid until hb_result_destroy() is called.\n Callers should not modify this buffer."]
    pub fn hb_result_get_table(
        result: hb_result_t,
        table_ptr: *mut *const ::std::os::raw::c_char,
        table_length_ptr: *mut usize,
    ) -> i32;
}
extern "C" {
    #[doc = " HBase 0.96 or later.\n Returns the namespace of this hb_result_t object.\n This buffer is valid until hb_result_destroy() is called.\n Callers should not modify this buffer."]
    pub fn hb_result_get_namespace(
        result: hb_result_t,
        namespace_ptr: *mut *const ::std::os::raw::c_char,
        namespace_length_ptr: *mut usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the total number of cells in this hb_result_t object."]
    pub fn hb_result_get_cell_count(result: hb_result_t, cell_count_ptr: *mut usize) -> i32;
}
extern "C" {
    #[doc = " Returns the pointer to a constant hb_cell_t structure with the most recent\n value of the given column. The buffers are valid until hb_result_destroy()\n is called. Callers should not modify these buffers.\n\n @returns 0       if operation succeeds.\n @returns ENOENT  if a matching cell is not found."]
    pub fn hb_result_get_cell(
        result: hb_result_t,
        family: *const byte_t,
        family_len: usize,
        qualifier: *const byte_t,
        qualifier_len: usize,
        cell_ptr: *mut *const hb_cell_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the pointer to a constant hb_cell_t structure containing the cell\n value at the given 0 based index of the result. The buffers are valid until\n hb_result_destroy() is called. Callers should not modify these buffers.\n\n @returns 0       if operation succeeds.\n @returns ERANGE  if the index is outside the bounds."]
    pub fn hb_result_get_cell_at(
        result: hb_result_t,
        index: usize,
        cell_ptr: *mut *const hb_cell_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the array of pointers to constant hb_cell_t structures with the cells\n of the result. The buffers are valid until hb_result_destroy() is called. The\n variable pointed by num_cells_ptr is set to the number of cells in the result.\n\n Calling this function multiple times for the same hb_result_t may return\n the same buffers. Callers should not modify these buffers."]
    pub fn hb_result_get_cells(
        result: hb_result_t,
        cells_ptr: *mut *mut *const hb_cell_t,
        num_cells_ptr: *mut usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Frees any resources held by the hb_result_t object."]
    pub fn hb_result_destroy(result: hb_result_t) -> i32;
}
extern "C" {
    #[doc = " Creates a client side row scanner. The returned scanner is not thread safe.\n No RPC will be invoked until the call to fetch the next set of rows is made.\n You can set the various attributes of this scanner until that point.\n @returns 0 on success, non-zero error code in case of failure."]
    pub fn hb_scanner_create(client: hb_client_t, scanner_ptr: *mut hb_scanner_t) -> i32;
}
extern "C" {
    #[doc = " Request the next set of results from the server. You can set the maximum\n number of rows returned by this call using hb_scanner_set_num_max_rows()."]
    pub fn hb_scanner_next(
        scanner: hb_scanner_t,
        cb: hb_scanner_cb,
        extra: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Close the scanner releasing any local and server side resources held.\n The call back is fired just before the scanner's memory is freed."]
    pub fn hb_scanner_destroy(
        scanner: hb_scanner_t,
        cb: hb_scanner_destroy_cb,
        extra: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Set the table name for the scanner"]
    pub fn hb_scanner_set_table(
        scanner: hb_scanner_t,
        table: *const ::std::os::raw::c_char,
        table_length: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Set the name space for the scanner (0.96 and above)"]
    pub fn hb_scanner_set_namespace(
        scanner: hb_scanner_t,
        name_space: *const ::std::os::raw::c_char,
        name_space_length: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Specifies the start row key for this scanner (inclusive)."]
    pub fn hb_scanner_set_start_row(
        scanner: hb_scanner_t,
        start_row: *const byte_t,
        start_row_length: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Specifies the end row key for this scanner (exclusive)."]
    pub fn hb_scanner_set_end_row(
        scanner: hb_scanner_t,
        end_row: *const byte_t,
        end_row_length: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the maximum versions of a column to fetch."]
    pub fn hb_scanner_set_num_versions(scanner: hb_scanner_t, num_versions: i8) -> i32;
}
extern "C" {
    #[doc = " Sets the maximum number of rows to scan per call to hb_scanner_next()."]
    pub fn hb_scanner_set_num_max_rows(scanner: hb_scanner_t, cache_size: usize) -> i32;
}
extern "C" {
    #[doc = " Optional. Adds a filter to the hb_scanner_t object.\n\n The filter must be specified using HBase Filter Language.\n Refer to class org.apache.hadoop.hbase.filter.ParseFilter and\n https://issues.apache.org/jira/browse/HBASE-4176 or\n http://hbase.apache.org/book.html#thrift.filter-language for\n language syntax and additional details."]
    pub fn hb_scanner_set_filter(
        scanner: hb_scanner_t,
        filter: *const byte_t,
        filterLen: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Optional. Adds a column family and optionally a column qualifier to\n the hb_scanner_t object."]
    pub fn hb_scanner_add_column(
        scanner: hb_scanner_t,
        family: *const byte_t,
        familyLen: usize,
        qualifier: *const byte_t,
        qualLen: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " Optional. Sets a timestamp on rows to scan"]
    pub fn hb_scanner_set_timestamp(scanner: hb_scanner_t, ts: i64) -> i32;
}
extern "C" {
    #[doc = " Optional. Sets a timerange on rows to scan"]
    pub fn hb_scanner_set_timerange(scanner: hb_scanner_t, min_ts: i64, max_ts: i64) -> i32;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
